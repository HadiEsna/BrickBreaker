#include "import_struct.h"int key_s[503];void Right_Left(double *angle) {    *angle = p - *angle;}void Up_Down(double *angle) {    *angle = -*angle;}int n;int dead_bal;int check_bomb(int j, int i) {    int ex = 0;    for (int y = j - 1; y <= j + 1; y++) {        if (y < 0 || y >= 3 * n) {            continue;        }        for (int x = i - 1; x <= i + 1; x++) {            if (x < 0 || x >= 3 * n || (x == i && y == j)) {                continue;            }            if (block[y][x] > 0) {                ex++;            }        }    }    return ex;}void block_breaek(int box_num_y, int box_num_x) {    block[box_num_y][box_num_x]--;    if (block[box_num_y][box_num_x] == 0) {        score++;        for (int y = box_num_y - 1; y <= box_num_y + 1; y++) {            if (y < 1 || y > 3 * n) {                continue;            }            for (int x = box_num_x - 1; x <= box_num_x + 1; x++) {                if (x < 0 || x > 2 * n || (x == box_num_x && y == box_num_y)) {                    continue;                }                if (block[y][x] < 0) {                    block[y][x] = -check_bomb(y, x);                }            }        }    }}void bomb(int j, int i) {    for (int y = j - 1; y <= j + 1; y++) {        if (y < 0 || y >= 3 * n) {            continue;        }        for (int x = i - 1; x <= i + 1; x++) {            if (x < 0 || x >= 3 * n || (x == i && y == j)) {                continue;            }            if (block[y][x] > 0) {                block[y][x]--;                if (block[y][x] == 0) {                    score++;                    for (int y = i - 1; y <= i + 1; y++) {                        if (y < 1 || y > 3 * n) {                            continue;                        }                        for (int x = j - 1; x <= j + 1; x++) {                            if (x < 0 || x > 2 * n || (x == j && y == i)) {                                continue;                            }                            if (block[y][x] < 0) {                                block[y][x] = -check_bomb(y, x);                            }                        }                    }                }            }        }    }    if (j == 0) {        block[j][i] = -1;        return;    }    block[j][i] = -check_bomb(j, i);}void move_ball(int ind) {    int x_perv = bal[ind].x;    int y_perv = bal[ind].y;    bal[ind].x += ball_Speed * (cos(bal[ind].ang));    bal[ind].y += ball_Speed * (sin(bal[ind].ang));    int f = 0;    int x_now = bal[ind].x, y_now = bal[ind].y;    int x_box = x_now % (box_width), y_box = y_now % (box_width), box_num_x = (x_now) / (box_width), box_num_y = y_now / (box_width);    if (x_now < x_perv && bal[ind].x < (ball_Speed + 2)) {        Right_Left(&(bal[ind].ang));        bal[ind].x -= ball_Speed * (cos(bal[ind].ang));        return;    }    if (x_now > x_perv && bal[ind].x > 600 - ball_Speed - 2) {        Right_Left(&(bal[ind].ang));        bal[ind].x -= ball_Speed * (cos(bal[ind].ang));        return;    }    if (y_perv > y_now && bal[ind].y < (ball_Speed + 2)) {        Up_Down(&(bal[ind].ang));        bal[ind].y -= ball_Speed * (sin(bal[ind].ang));        return;    }    if (bal[ind].y > 900) {        bal[ind].ex = 0;        dead_bal++;        return;    }    if (x_now < x_perv && x_box < (ball_Speed + 2) && block[box_num_y][box_num_x - 1] != 0) {        bal[ind].x -= ball_Speed * (cos(bal[ind].ang));        Right_Left(&(bal[ind].ang));        if (block[box_num_y][box_num_x - 1] > 0)            block_breaek(box_num_y, box_num_x - 1);        if (block[box_num_y][box_num_x - 1] < 0)            bomb(box_num_y, box_num_x - 1);        return;    }    if (x_now > x_perv && x_box > (box_width) - (ball_Speed + 2) && block[box_num_y][box_num_x + 1] != 0) {        bal[ind].x -= ball_Speed * (cos(bal[ind].ang));        Right_Left(&(bal[ind].ang));        if (block[box_num_y][box_num_x + 1] > 0)            block_breaek(box_num_y, box_num_x + 1);        if (block[box_num_y][box_num_x + 1] < 0)            bomb(box_num_y, box_num_x + 1);        return;    }    if (y_now < y_perv && y_box < (ball_Speed + 2) && block[box_num_y - 1][box_num_x] != 0) {        bal[ind].y -= ball_Speed * (sin(bal[ind].ang));        Up_Down(&(bal[ind].ang));        if (block[box_num_y - 1][box_num_x] > 0)            block_breaek(box_num_y - 1, box_num_x);        if (block[box_num_y - 1][box_num_x] < 0)            bomb(box_num_y - 1, box_num_x);        return;    }    if (y_now > y_perv && y_box + (ball_Speed + 2) > box_width && block[box_num_y + 1][box_num_x] != 0) {        bal[ind].y -= ball_Speed * (sin(bal[ind].ang));        Up_Down(&(bal[ind].ang));        if (block[box_num_y + 1][box_num_x] > 0)            block_breaek(box_num_y + 1, box_num_x);        if (block[box_num_y + 1][box_num_x] < 0)            bomb(box_num_y + 1, box_num_x);        return;    }    if (x_now < x_perv && y_now < y_perv && x_box <= (ball_Speed + 1) && y_box <= (ball_Speed + 1) && x_perv > x_now && y_perv > y_now) {        if (block[box_num_y - 1][box_num_x - 1] != 0) {            bal[ind].x -= ball_Speed * (cos(bal[ind].ang));            bal[ind].y -= ball_Speed * (sin(bal[ind].ang));            Right_Left(&(bal[ind].ang));            Up_Down(&(bal[ind].ang));            if (block[box_num_y - 1][box_num_x - 1] > 0)                block_breaek(box_num_y - 1, box_num_x - 1);            if (block[box_num_y - 1][box_num_x - 1] < 0)                bomb(box_num_y - 1, box_num_x - 1);        }        return;    }    if (x_now < x_perv && y_now > y_perv && x_box <= (ball_Speed + 1) && y_box + (ball_Speed + 1) >= (box_width) && x_perv > x_now && y_perv < y_now) {        if (block[box_num_y + 1][box_num_x - 1] != 0) {            bal[ind].x -= ball_Speed * (cos(bal[ind].ang));            bal[ind].y -= ball_Speed * (sin(bal[ind].ang));            Right_Left(&(bal[ind].ang));            Up_Down(&(bal[ind].ang));            if (block[box_num_y + 1][box_num_x - 1] > 0)                block_breaek(box_num_y + 1, box_num_x - 1);            if (block[box_num_y + 1][box_num_x - 1] < 0)                bomb(box_num_y + 1, box_num_x - 1);        }        return;    }    if (x_now > x_perv && y_now < y_perv && x_box + (ball_Speed + 1) >= (box_width) && y_box <= (ball_Speed + 1) && x_perv < x_now && y_perv > y_now) {        if (block[box_num_y - 1][box_num_x + 1] != 0) {            bal[ind].x -= ball_Speed * (cos(bal[ind].ang));            bal[ind].y -= ball_Speed * (sin(bal[ind].ang));            Right_Left(&(bal[ind].ang));            Up_Down(&(bal[ind].ang));            if (block[box_num_y - 1][box_num_x + 1] > 0)                block_breaek(box_num_y - 1, box_num_x + 1);            if (block[box_num_y - 1][box_num_x + 1] < 0)                bomb(box_num_y - 1, box_num_x + 1);        }        return;    }    if (x_now > x_perv && y_now > y_perv && x_box + (ball_Speed + 1) >= (box_width) && y_box + (ball_Speed + 1) >= (box_width) && x_perv < x_now && y_perv < y_now) {        if (block[box_num_y + 1][box_num_x + 1] != 0) {            Right_Left(&(bal[ind].ang));            Up_Down(&(bal[ind].ang));            bal[ind].x -= ball_Speed * (cos(bal[ind].ang));            bal[ind].y -= ball_Speed * (sin(bal[ind].ang));            if (block[box_num_y + 1][box_num_x + 1] > 0)                block_breaek(box_num_y + 1, box_num_x + 1);            if (block[box_num_y + 1][box_num_x + 1] < 0)                bomb(box_num_y + 1, box_num_x + 1);        }        return;    }}void move_gun() {    gg.x += (key_s[SDLK_RIGHT % 503] - key_s[SDLK_LEFT % 503]) * speed;    gg.ang -= (key_s[SDLK_KP_1 % 503] - key_s[SDLK_KP_2 % 503]) * w * 0.1;    if (gg.x > 600 - gun_rad || gg.x < gun_rad)        gg.x -= speed * (key_s[SDLK_RIGHT % 503] - key_s[SDLK_LEFT % 503]);    if (sin(gg.ang) > -0.15) {        gg.ang += w * (key_s[SDLK_KP_1 % 503] - key_s[SDLK_KP_2 % 503] * 0.1);    }}int keyboard() {    SDL_Event event;    static bool first = 1;    if (first) {        first = 0;        return 0;    }    if (SDL_PollEvent(&event)) {        if (event.type == SDL_QUIT)            return 1234;        if (event.type == SDL_KEYDOWN) {            key_s[event.key.keysym.sym % 503] = 1;            if (event.key.keysym.sym == SDLK_q)                return 1234;            if (event.key.keysym.sym == SDLK_SPACE && !shot) {                if (make_ball() == 1234)                    return 1234;                tedad_toop_haye_shelik_shode = 0;                score_perv = score;                can_save = 1;            }            if (event.key.keysym.sym == SDLK_s && can_save) {                can_save = 0;                save();            }        }        if (event.type == SDL_KEYUP) {            key_s[event.key.keysym.sym % 503] = 0;        }    }}int keyboard_shot() {    SDL_Event event;    if (SDL_PollEvent(&event)) {        if (event.type == SDL_QUIT)            return 1234;        if (event.type == SDL_KEYDOWN) {            if (event.key.keysym.sym == SDLK_q)                return 1234;        }    }}int make_ball() {    dead_bal = 0;    shot = 1;    int i;    for (i = 0; i < score; i++) {        bal[i].ex = 0;        bal[i].x = gg.x + 25 * cos(gg.ang);        bal[i].y = 894 + 25 * sin(gg.ang);        bal[i].ang = gg.ang;    }    int time;    tedad_toop_haye_shelik_shode = 0;    int last_shot = SDL_GetTicks();    while (shot) {        if (SDL_GetTicks() - last_shot > 100 && tedad_toop_haye_shelik_shode < score_perv) {            bal[tedad_toop_haye_shelik_shode].ex = 1;            tedad_toop_haye_shelik_shode++;            last_shot = SDL_GetTicks();        }        time = SDL_GetTicks();        if (dead_bal >=  score_perv) {            shot = 0;            pull_down();            break;        }        for (i = 0; i < score_perv; i++) {            if (bal[i].ex) {                move_ball(i);            }        }        if (keyboard_shot() == 1234) {            return 1234;        }        draw();        while (SDL_GetTicks() - time < 1000 / FPS);    }}